{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CyberDB Chinese Version CyberDB is a lightweight Python in-memory database. It is designed to use Python's built-in data structures Dictionaries, Lists for data storage, efficient communication through Socket TCP, and provide data persistence. This module can be used in hard disk database caching, Gunicorn inter-process communication, distributed computing and other fields. The CyberDB server uses Asyncio for TCP communication. The client is developed based on Socket, so it supports the Gevent coroutine, but it has not yet adapted to Asyncio. Both the server and the client support PyPy, and it is recommended to use PyPy to run for better performance. In high concurrency scenarios, the performance bottleneck of traditional databases is mainly hard disk I/O. Even if CyberDB is developed based on the dynamic language Python, the speed is still much faster than that of hard disk databases (such as MySQL), and CyberDB can be used as its cache. In addition, the core of CyberDB lies in programming in a Pythonic way, you can use CyberDB like Dictionaries and Lists. Installation Enter the command window, create a virtual environment, and enter the following commands in turn Linux and macOS: python3 -m venv venv # Create a virtual environment. . venv/bin/activate # Activate the virtual environment. Windows: python -m venv venv # Create a virtual environment. venv\\Scripts\\activate # Activate the virtual environment. 2.Install CyberDB, enter pip install --upgrade pip pip install cyberdb If your server and client are running in two different project directories, please install CyberDB in the virtual environment of the server and client respectively. Links GitHub: https://github.com/Cyberbolt/CyberDB PyPI: https://pypi.org/project/CyberDB/ Documentation: https://www.cyberlight.xyz/static/cyberdb CyberLight: https://www.cyberlight.xyz/ Quick to Use In this module, please use CyberDict and CyberList instead of dict and list (a TCP-based Dictionaries-like, Lists-like object). Server Run the database server. import time import cyberdb db = cyberdb.Server() # The data is persistent, the backup file is data.cdb, and the backup cycle is every 900 seconds. db.set_backup('data.cdb', cycle=900) # Set the TCP address, port number, and password. # The start method will not block the operation. If you want the operation to block, please use the run method instead of start, and the parameters remain unchanged. db.start(host='127.0.0.1', port=9980, password='123456') while True: time.sleep(10000) After the above server runs, data.cdb and data_backup.cdb (backup files) will be generated (or overwritten) in the project root directory every 900 seconds. The file can be read the next time the database is started using the load method. Client Connect to the Database import cyberdb # Generate a client instance and connect. client = cyberdb.connect(host='127.0.0.1', port=9980, password='123456') Generate proxy Object # Generate proxy for this request. proxy = client.get_proxy() # Automatically obtain database connections from the connection pool. proxy.connect() The proxy object is not thread-safe, please generate the proxy object separately in each thread (or coroutine), and obtain the database connection through the connect method. You only need to use the close method to return the connection after the operation is completed, and the returned connection is managed intelligently by the client object. Manipulate proxy Objects Create CyberDict and CyberList # Create dict1 and dict2 tables of type CyberDict and # list1 table of type CyberList in the database respectively. proxy.create_cyberdict('dict1') proxy.create_cyberdict('dict2') proxy.create_cyberlist('list1') dict1 = proxy.get_cyberdict('dict1') dict2 = proxy.get_cyberdict('dict2') list1 = proxy.get_cyberlist('list1') The dict1, dict2, and list1 obtained here are all network objects, and the data is transmitted through TCP. The three objects are controlled by the proxy, and when proxy.close() is called to return the connection, the three objects will also be invalid. Similarly, use proxy.connect() to get connections from the connection pool again, and dict1, dict2, list1 also become available. Once you understand this operation, you can operate dict1, dict2 like Dictionaries, and list1 like Lists! (CyberDict and CyberList support most methods of Dictionaries, Lists) Examples are as follows Common Operations of CyberDict Add key-value pairs in dict1 and dict2 dict1[0] = 100 dict1['test'] = 'Hello CyberDB!' dict2[0] = 200 Get the corresponding value dict1.get(0) 100 dict2[0] 200 View dict1 and dict2 (can also be printed with print ) dict1 {0: 100, 'test': 'Hello CyberDB!'} dict2 {0: 200} Get length len(dict1) 2 Delete key-value pair del dict1[0] dict1 {'test': 'Hello CyberDB!'} Empty dict1 dict1.clear() dict1 {} Common Operations of CyberList Generate the contents of list1 for i in range(5): list1.append(99) list1 [99, 99, 99, 99, 99] Change coordinate values list1[3] = 100 list1 [99, 99, 99, 100, 99] To slice list1[3:] [100, 99] Get the length of list1 len(list1) 5 Print each element of list1 by iterating for v in list1: print(v) 99 99 99 100 99 It is strongly recommended to use a for loop to iterate CyberList, each iteration will get v from the server, and the space complexity of the client is o(1). Iteration can also be used for CyberDict. In the iteration of CyberDict, the client space complexity is o(n), and n is the size of CyberDict.keys(). Release the Proxy Object After the use is complete, return the connection of the proxy to the connection pool. proxy.close() The proxy object also supports context managers, such as with client.get_proxy() as proxy: list1 = proxy.get_cyberlist('list1') print(list1) [99, 99, 99, 100, 99] Generalize With CyberDB, memory performance can be fully utilized, and different processes (or even different hosts) can communicate through Python's data structures. For more tutorials, please refer to the documentation, Thank you! Notice Due to encoding limitations, CyberDB will recognize 0 as None, but it does not affect the calculation, please convert None to 0 in the desired position.","title":"Home"},{"location":"#cyberdb","text":"Chinese Version CyberDB is a lightweight Python in-memory database. It is designed to use Python's built-in data structures Dictionaries, Lists for data storage, efficient communication through Socket TCP, and provide data persistence. This module can be used in hard disk database caching, Gunicorn inter-process communication, distributed computing and other fields. The CyberDB server uses Asyncio for TCP communication. The client is developed based on Socket, so it supports the Gevent coroutine, but it has not yet adapted to Asyncio. Both the server and the client support PyPy, and it is recommended to use PyPy to run for better performance. In high concurrency scenarios, the performance bottleneck of traditional databases is mainly hard disk I/O. Even if CyberDB is developed based on the dynamic language Python, the speed is still much faster than that of hard disk databases (such as MySQL), and CyberDB can be used as its cache. In addition, the core of CyberDB lies in programming in a Pythonic way, you can use CyberDB like Dictionaries and Lists.","title":"CyberDB"},{"location":"#installation","text":"Enter the command window, create a virtual environment, and enter the following commands in turn Linux and macOS: python3 -m venv venv # Create a virtual environment. . venv/bin/activate # Activate the virtual environment. Windows: python -m venv venv # Create a virtual environment. venv\\Scripts\\activate # Activate the virtual environment. 2.Install CyberDB, enter pip install --upgrade pip pip install cyberdb If your server and client are running in two different project directories, please install CyberDB in the virtual environment of the server and client respectively.","title":"Installation"},{"location":"#links","text":"GitHub: https://github.com/Cyberbolt/CyberDB PyPI: https://pypi.org/project/CyberDB/ Documentation: https://www.cyberlight.xyz/static/cyberdb CyberLight: https://www.cyberlight.xyz/","title":"Links"},{"location":"#quick-to-use","text":"In this module, please use CyberDict and CyberList instead of dict and list (a TCP-based Dictionaries-like, Lists-like object).","title":"Quick to Use"},{"location":"#server","text":"Run the database server. import time import cyberdb db = cyberdb.Server() # The data is persistent, the backup file is data.cdb, and the backup cycle is every 900 seconds. db.set_backup('data.cdb', cycle=900) # Set the TCP address, port number, and password. # The start method will not block the operation. If you want the operation to block, please use the run method instead of start, and the parameters remain unchanged. db.start(host='127.0.0.1', port=9980, password='123456') while True: time.sleep(10000) After the above server runs, data.cdb and data_backup.cdb (backup files) will be generated (or overwritten) in the project root directory every 900 seconds. The file can be read the next time the database is started using the load method.","title":"Server"},{"location":"#client","text":"","title":"Client"},{"location":"#connect-to-the-database","text":"import cyberdb # Generate a client instance and connect. client = cyberdb.connect(host='127.0.0.1', port=9980, password='123456')","title":"Connect to the Database"},{"location":"#generate-proxy-object","text":"# Generate proxy for this request. proxy = client.get_proxy() # Automatically obtain database connections from the connection pool. proxy.connect() The proxy object is not thread-safe, please generate the proxy object separately in each thread (or coroutine), and obtain the database connection through the connect method. You only need to use the close method to return the connection after the operation is completed, and the returned connection is managed intelligently by the client object.","title":"Generate proxy Object"},{"location":"#manipulate-proxy-objects","text":"Create CyberDict and CyberList # Create dict1 and dict2 tables of type CyberDict and # list1 table of type CyberList in the database respectively. proxy.create_cyberdict('dict1') proxy.create_cyberdict('dict2') proxy.create_cyberlist('list1') dict1 = proxy.get_cyberdict('dict1') dict2 = proxy.get_cyberdict('dict2') list1 = proxy.get_cyberlist('list1') The dict1, dict2, and list1 obtained here are all network objects, and the data is transmitted through TCP. The three objects are controlled by the proxy, and when proxy.close() is called to return the connection, the three objects will also be invalid. Similarly, use proxy.connect() to get connections from the connection pool again, and dict1, dict2, list1 also become available. Once you understand this operation, you can operate dict1, dict2 like Dictionaries, and list1 like Lists! (CyberDict and CyberList support most methods of Dictionaries, Lists) Examples are as follows","title":"Manipulate proxy Objects"},{"location":"#common-operations-of-cyberdict","text":"Add key-value pairs in dict1 and dict2 dict1[0] = 100 dict1['test'] = 'Hello CyberDB!' dict2[0] = 200 Get the corresponding value dict1.get(0) 100 dict2[0] 200 View dict1 and dict2 (can also be printed with print ) dict1 {0: 100, 'test': 'Hello CyberDB!'} dict2 {0: 200} Get length len(dict1) 2 Delete key-value pair del dict1[0] dict1 {'test': 'Hello CyberDB!'} Empty dict1 dict1.clear() dict1 {}","title":"Common Operations of CyberDict"},{"location":"#common-operations-of-cyberlist","text":"Generate the contents of list1 for i in range(5): list1.append(99) list1 [99, 99, 99, 99, 99] Change coordinate values list1[3] = 100 list1 [99, 99, 99, 100, 99] To slice list1[3:] [100, 99] Get the length of list1 len(list1) 5 Print each element of list1 by iterating for v in list1: print(v) 99 99 99 100 99 It is strongly recommended to use a for loop to iterate CyberList, each iteration will get v from the server, and the space complexity of the client is o(1). Iteration can also be used for CyberDict. In the iteration of CyberDict, the client space complexity is o(n), and n is the size of CyberDict.keys().","title":"Common Operations of CyberList"},{"location":"#release-the-proxy-object","text":"After the use is complete, return the connection of the proxy to the connection pool. proxy.close() The proxy object also supports context managers, such as with client.get_proxy() as proxy: list1 = proxy.get_cyberlist('list1') print(list1) [99, 99, 99, 100, 99]","title":"Release the Proxy Object"},{"location":"#generalize","text":"With CyberDB, memory performance can be fully utilized, and different processes (or even different hosts) can communicate through Python's data structures. For more tutorials, please refer to the documentation, Thank you!","title":"Generalize"},{"location":"#notice","text":"Due to encoding limitations, CyberDB will recognize 0 as None, but it does not affect the calculation, please convert None to 0 in the desired position.","title":"Notice"},{"location":"API/","text":"API This part of the documentation covers all the interfaces of CyberDB. For the parts of CyberDB that depend on external libraries, we document the most important parts here and provide a link to the specification document. cyberdb.Server Class class cyberdb.Server This class is used to create CyberDB server objects. def start(self, host: str = '127.0.0.1', port: int = 9980, password: str = None, max_con: int = 500, timeout: int = 0, print_log: bool = False, encrypt: bool = False): ''' Starts the CyberDB server in the background, which does not block foreground tasks. Parameters: host -- TCP listening host address, such as 127.0.0.1. port \u2013 TCP listening port. password -- TCP communication password, it is recommended to use a combination of English letters and numbers, Up to 32 characters long. max_con -- the maximum number of concurrency. timeout -- The timeout for a single connection, in seconds. print_log -- whether to print the communication log, Fasle does not print it. encrypt -- Whether to encrypt the communication content, Fasle is not encrypted. The encryption algorithm is AES-256 and the key is password. Return Type: None ''' def run(self, host: str = '127.0.0.1', port: int = 9980, password: str = None, max_con: int = 500, timeout: int = 0, print_log: bool = False, encrypt: bool = False): ''' Running the CyberDB server in the foreground blocks foreground tasks. The parameters are the same as the start method. Return Type: None ''' def set_ip_whitelist(self, ips: list): ''' Set the ip whitelist. When CyberDB encrypts communication, only whitelisted ip connections are allowed. This method only works if cyberdb.Server.start(encrypt=True) or cyberdb.Server.run(encrypt=True) are enabled. Parameters: ips -- the type is a list, the format is ['192.168.1.1', '118.123.89.137'] Return Type: None ''' def set_backup(self, file_name: str = 'data.cdb', cycle: int = 900): ''' Set timed backup. After this operation is set, data persistent backup will be performed at the specified period, and the CyberDB database will be saved to the hard disk. parameter: file_name -- the name of the file generated by the backup, the file suffix must be .cdb. cycle -- The cycle of the cyclic backup, in seconds. Return Type: None ''' def save_db(self, file_name: str = 'data.cdb'): ''' Data persistence, save the CyberDB database to the hard disk. parameter: file_name -- the name of the file generated by the backup, the file suffix must be .cdb. Return Type: None ''' def load_db(self, file_name: str = 'data.cdb'): ''' Load a file in .cdb format to load the CyberDB database backed up from the hard disk back into memory. parameter: file_name -- the file name generated by data persistence, the file suffix must be .cdb. Return Type: None ''' cyberdb.connect Function def cyberdb.connect(host: str = '127.0.0.1', port: int = 9980, password: str = None, encrypt: bool = False, time_out: int = None) -> Client: ''' Connect the client to the CyberDB server. Parameters: host -- the connection address, such as 127.0.0.1 port -- connection port password -- connection password encrypt -- Whether to encrypt communication, if the server enables encrypt to be True, it must be True here, and vice versa. time_out -- The timeout for each connection in the connection pool, in seconds. Connections in the connection pool will be discarded after time_out seconds of inactivity, and a new connection will be generated next time. The connection pool will manage the connections automatically, and the developer does not need to pay attention to the details. If this parameter is None, there will be no timeout, and the connection pool will maintain the connection until it expires, after which a new connection will be regenerated. Return Type: Client ''' cyberdb.Client Class class cyberdb.Client The cyberdb.Client object returned by the cyberdb.connect function is used to generate the Proxy object. def get_proxy(self) -> Proxy: ''' Generate a Proxy object. Return Type: None ''' Proxy Class The Proxy object generated by the cyberdb.Client.get_proxy method can operate on the CyberDB database and manage the TCP connections of the CyberDict and CyberList sub-objects generated by the Proxy. After the Proxy object is initialized, it can be used after executing the Proxy.connect method. The Proxy object and its sub-objects will perform remote operations on the server-side CyberDB database. class Proxy def connect(self): ''' Get a TCP connection from the connection pool and bind it to the Proxy object. Return Type: None ''' def close(self): ''' Cancel the TCP connection bound to the Proxy object and return it to the connection pool. It needs to be reset before the next operation. Execute the Proxy.connect method. Return Type: None ''' def create_cyberdict(self, table_name: str, content: dict = {}): ''' Create a CyberDict table. Parameters: table_name \u2013 table name. content -- table content, needs to be a dictionary type, the default is an empty dictionary. Return Type: None ''' def create_cyberlist(self, table_name: str, content: list = []): ''' Create the CyberList table. Parameters: table_name \u2013 table name. content -- table content, it needs to be a list type, the default is an empty list. Return Type: None ''' def get_cyberdict(self, table_name: str) -> CyberDict: ''' Get the CyberDict table. Parameters: table_name \u2013 table name. Return Type: CyberDict, which is a sub-object generated by Proxy, which controls the TCP connection. ''' def get_cyberlist(self, table_name: str) -> CyberList: ''' Get the CyberList table. Parameters: table_name \u2013 table name. Return type: CyberList, which is a sub-object generated by Proxy, which controls the TCP connection. ''' def print_tables(self): ''' Print all tables in the CyberDB database. Return Type: None ''' def delete_table(self, table_name: str): ''' Drop the table_name table in the CyberDB database. Parameters: table_name \u2013 the name of the table to drop. Return Type: None ''' cyberdb.CyberDict Class class cyberdb.CyberDict A child object generated by a Proxy object for performing Dictionaries operations. This object will perform remote operations on the server-side CyberDB database. Shares the same TCP connection with the Proxy object. The connection will follow the connection of the Proxy. After the Proxy releases the connection, the object will also lose the connection. CyberDict can execute the get, setdefault, update, keys, values, items, pop, popitem, clear methods and common magic methods of Dictionaries, please refer to Python dictionary official documentation . Iterate over CyberDict using a for loop with client space complexity o(n), where n is the length of CyberDict.keys() . def todict(self) -> Dict: ''' Convert CyberDict to Dictionaries. Return Type: Dict ''' cyberdb.CyberList \u7c7b class cyberdb.CyberList A child object generated by a Proxy object for performing Lists operations. This object will perform remote operations on the server-side CyberDB database. Shares the same TCP connection with the Proxy object. The connection will follow the connection of the Proxy. After the Proxy releases the connection, the object will also lose the connection. CyberList can execute the append, extend, insert, pop, remove, count, index, reverse, sort, clear methods and common magic methods of Lists, please refer to Python List Official Documentation . The CyberList is iterated using a for loop, each iteration will fetch the content from the server, and the space complexity of the client is o(1). def tolist(self) -> List: ''' Convert CyberList to Lists. Return Type: List '''","title":"API"},{"location":"API/#api","text":"This part of the documentation covers all the interfaces of CyberDB. For the parts of CyberDB that depend on external libraries, we document the most important parts here and provide a link to the specification document.","title":"API"},{"location":"API/#cyberdbserver-class","text":"class cyberdb.Server This class is used to create CyberDB server objects. def start(self, host: str = '127.0.0.1', port: int = 9980, password: str = None, max_con: int = 500, timeout: int = 0, print_log: bool = False, encrypt: bool = False): ''' Starts the CyberDB server in the background, which does not block foreground tasks. Parameters: host -- TCP listening host address, such as 127.0.0.1. port \u2013 TCP listening port. password -- TCP communication password, it is recommended to use a combination of English letters and numbers, Up to 32 characters long. max_con -- the maximum number of concurrency. timeout -- The timeout for a single connection, in seconds. print_log -- whether to print the communication log, Fasle does not print it. encrypt -- Whether to encrypt the communication content, Fasle is not encrypted. The encryption algorithm is AES-256 and the key is password. Return Type: None ''' def run(self, host: str = '127.0.0.1', port: int = 9980, password: str = None, max_con: int = 500, timeout: int = 0, print_log: bool = False, encrypt: bool = False): ''' Running the CyberDB server in the foreground blocks foreground tasks. The parameters are the same as the start method. Return Type: None ''' def set_ip_whitelist(self, ips: list): ''' Set the ip whitelist. When CyberDB encrypts communication, only whitelisted ip connections are allowed. This method only works if cyberdb.Server.start(encrypt=True) or cyberdb.Server.run(encrypt=True) are enabled. Parameters: ips -- the type is a list, the format is ['192.168.1.1', '118.123.89.137'] Return Type: None ''' def set_backup(self, file_name: str = 'data.cdb', cycle: int = 900): ''' Set timed backup. After this operation is set, data persistent backup will be performed at the specified period, and the CyberDB database will be saved to the hard disk. parameter: file_name -- the name of the file generated by the backup, the file suffix must be .cdb. cycle -- The cycle of the cyclic backup, in seconds. Return Type: None ''' def save_db(self, file_name: str = 'data.cdb'): ''' Data persistence, save the CyberDB database to the hard disk. parameter: file_name -- the name of the file generated by the backup, the file suffix must be .cdb. Return Type: None ''' def load_db(self, file_name: str = 'data.cdb'): ''' Load a file in .cdb format to load the CyberDB database backed up from the hard disk back into memory. parameter: file_name -- the file name generated by data persistence, the file suffix must be .cdb. Return Type: None '''","title":"cyberdb.Server Class"},{"location":"API/#cyberdbconnect-function","text":"def cyberdb.connect(host: str = '127.0.0.1', port: int = 9980, password: str = None, encrypt: bool = False, time_out: int = None) -> Client: ''' Connect the client to the CyberDB server. Parameters: host -- the connection address, such as 127.0.0.1 port -- connection port password -- connection password encrypt -- Whether to encrypt communication, if the server enables encrypt to be True, it must be True here, and vice versa. time_out -- The timeout for each connection in the connection pool, in seconds. Connections in the connection pool will be discarded after time_out seconds of inactivity, and a new connection will be generated next time. The connection pool will manage the connections automatically, and the developer does not need to pay attention to the details. If this parameter is None, there will be no timeout, and the connection pool will maintain the connection until it expires, after which a new connection will be regenerated. Return Type: Client '''","title":"cyberdb.connect Function"},{"location":"API/#cyberdbclient-class","text":"class cyberdb.Client The cyberdb.Client object returned by the cyberdb.connect function is used to generate the Proxy object. def get_proxy(self) -> Proxy: ''' Generate a Proxy object. Return Type: None '''","title":"cyberdb.Client Class"},{"location":"API/#proxy-class","text":"The Proxy object generated by the cyberdb.Client.get_proxy method can operate on the CyberDB database and manage the TCP connections of the CyberDict and CyberList sub-objects generated by the Proxy. After the Proxy object is initialized, it can be used after executing the Proxy.connect method. The Proxy object and its sub-objects will perform remote operations on the server-side CyberDB database. class Proxy def connect(self): ''' Get a TCP connection from the connection pool and bind it to the Proxy object. Return Type: None ''' def close(self): ''' Cancel the TCP connection bound to the Proxy object and return it to the connection pool. It needs to be reset before the next operation. Execute the Proxy.connect method. Return Type: None ''' def create_cyberdict(self, table_name: str, content: dict = {}): ''' Create a CyberDict table. Parameters: table_name \u2013 table name. content -- table content, needs to be a dictionary type, the default is an empty dictionary. Return Type: None ''' def create_cyberlist(self, table_name: str, content: list = []): ''' Create the CyberList table. Parameters: table_name \u2013 table name. content -- table content, it needs to be a list type, the default is an empty list. Return Type: None ''' def get_cyberdict(self, table_name: str) -> CyberDict: ''' Get the CyberDict table. Parameters: table_name \u2013 table name. Return Type: CyberDict, which is a sub-object generated by Proxy, which controls the TCP connection. ''' def get_cyberlist(self, table_name: str) -> CyberList: ''' Get the CyberList table. Parameters: table_name \u2013 table name. Return type: CyberList, which is a sub-object generated by Proxy, which controls the TCP connection. ''' def print_tables(self): ''' Print all tables in the CyberDB database. Return Type: None ''' def delete_table(self, table_name: str): ''' Drop the table_name table in the CyberDB database. Parameters: table_name \u2013 the name of the table to drop. Return Type: None '''","title":"Proxy Class"},{"location":"API/#cyberdbcyberdict-class","text":"class cyberdb.CyberDict A child object generated by a Proxy object for performing Dictionaries operations. This object will perform remote operations on the server-side CyberDB database. Shares the same TCP connection with the Proxy object. The connection will follow the connection of the Proxy. After the Proxy releases the connection, the object will also lose the connection. CyberDict can execute the get, setdefault, update, keys, values, items, pop, popitem, clear methods and common magic methods of Dictionaries, please refer to Python dictionary official documentation . Iterate over CyberDict using a for loop with client space complexity o(n), where n is the length of CyberDict.keys() . def todict(self) -> Dict: ''' Convert CyberDict to Dictionaries. Return Type: Dict '''","title":"cyberdb.CyberDict Class"},{"location":"API/#cyberdbcyberlist","text":"class cyberdb.CyberList A child object generated by a Proxy object for performing Lists operations. This object will perform remote operations on the server-side CyberDB database. Shares the same TCP connection with the Proxy object. The connection will follow the connection of the Proxy. After the Proxy releases the connection, the object will also lose the connection. CyberList can execute the append, extend, insert, pop, remove, count, index, reverse, sort, clear methods and common magic methods of Lists, please refer to Python List Official Documentation . The CyberList is iterated using a for loop, each iteration will fetch the content from the server, and the space complexity of the client is o(1). def tolist(self) -> List: ''' Convert CyberList to Lists. Return Type: List '''","title":"cyberdb.CyberList \u7c7b"}]}